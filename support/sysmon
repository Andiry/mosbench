#!/usr/bin/python

import sys, os, time, subprocess

SC_CLK_TCK = float(os.sysconf("SC_CLK_TCK"))

def diff(a, b):
    return [a1 - b1 for a1, b1 in zip(a, b)]

class TimeMonitor(object):
    COLS = ["user", "nice", "sys", "idle",
            "iowait", "irq", "softirq",
            "steal", "guest"]

    def __init__(self):
        self.__f = file("/proc/stat", "r", 0)

    def sample(self):
        self.__f.seek(0)
        for l in self.__f:
            if not l.startswith("cpu "):
                continue
            return ([int(p)/SC_CLK_TCK for p in l[4:].strip().split()],
                    time.time())
        raise RuntimeError("Failed to find CPU statistics")

    def delta(self, (start, sreal), (end, ereal)):
        delta = diff(end, start)
        if len(delta) < len(self.COLS):
            delta.extend([0] * (len(self.COLS) - len(delta)))
        out = ["real", str(ereal - sreal)]
        for c, d in zip(self.COLS, delta):
            out.extend([c, "%g" % d])
        return " ".join(out)

args = sys.argv[1:]

match = proc = None
if len(args) == 0:
    f = sys.stdin
else:
    if args[0] == "-m":
        args.pop(0)
        match = args.pop(0)
    # XXX Use a PTY to avoid flushing issues?
    proc = subprocess.Popen(args, stdout = subprocess.PIPE)
    f = proc.stdout

m = TimeMonitor()
if match == None:
    start = m.sample()
while True:
    l = f.readline()
    if not l:
        break
    if l.rstrip("\n") == match:
        start = m.sample()
        match = None
    sys.stdout.write(l)
    sys.stdout.flush()
end = m.sample()
if match == None:
    print "[TimeMonitor]", m.delta(start, end)
if proc:
    ret = proc.wait()
    if ret == 0 and match != None:
        print >> sys.stderr, "Monitor trigger line %r never read" % match
    if ret >= 0:
        sys.exit(ret)
    else:
        os.kill(os.getpid(), -ret)
