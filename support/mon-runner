#!/usr/bin/python

FIFO_BASE_PATH = "/tmp/mon-runner-"
IP_BASE_PORT = 23584

import sys, os, socket, select, signal, subprocess, errno

def usage():
    print >> sys.stderr, """Usage: %s cmd...

Runs the specified command while there are connections to the control
FIFO or socket.  When the last connection closes, this sends the child
process a SIGINT.

To start monitoring using the control FIFO from Python:
    try:
        os.write(os.open("%s%%d" %% os.getuid(), os.O_WRONLY|os.O_NONBLOCK), "x")
    except EnvironmentError: pass

To use the control socket from Python:
    try:
        sock = socket.create_connection(("hostname", %d+os.getuid()%%10000))
    except socket.error: pass
Make sure sock doesn't go out of scope.

To use the control FIFO from C:
    char path[128];
    snprintf(path, sizeof path, "%s%%d", getuid());
    write(open(path, O_WRONLY|O_NONBLOCK), "x", 1);
""" % (sys.argv[0], FIFO_BASE_PATH, IP_BASE_PORT, FIFO_BASE_PATH)
    sys.exit(2)

def makeMasters():
    fifoPath = "%s%d" % (FIFO_BASE_PATH, os.getuid())
    try:
        os.mkfifo(fifoPath)
    except EnvironmentError, e:
        if e.errno != errno.EEXIST:
            raise
    fifo = os.open(fifoPath, os.O_RDONLY|os.O_NONBLOCK)

    sock = socket.socket(socket.AF_INET)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(("", IP_BASE_PORT + os.getpid() % 10000))
    sock.listen(5)

    return fifo, sock

proc = None

def start():
    global proc
    proc = subprocess.Popen(sys.argv[1:], close_fds = True)

def stop():
    global proc
    os.kill(proc.pid, signal.SIGINT)
    status = proc.wait()
    proc = None
    if status < 0:
        os.kill(os.getpid(), -status)
    else:
        sys.exit(status)

def kill():
    global proc
    if proc:
        os.kill(proc.pid, signal.SIGKILL)
        proc = None

def loop(fifo, sock):
    masters = [fifo, sock]
    clients = []

    print "# mon-runner ready"
    sys.stdout.flush()
    while clients or not proc:
        rset, _, _ = select.select(masters + clients, [], [])
        for fp in rset:
            if fp == fifo:
                x = os.read(fp, 1)
                if len(x) == 0:
                    # When the last writer closes the FIFO, we read an EOF.
                    os.close(fp)
                    clients.remove(fp)
                else:
                    # Somebody opened the FIFO and wrote a hello byte.
                    if fp not in clients:
                        masters.remove(fp)
                        clients.append(fp)
            elif fp == sock:
                client, _ = fp.accept()
                clients.append(client)
            else:
                clients.remove(fp)

            if clients and not proc:
                start()

    stop()

if __name__ == "__main__":
    if len(sys.argv) == 1:
        usage()
    try:
        loop(*makeMasters())
    except KeyboardInterrupt:
        pass
    finally:
        kill()
