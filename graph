#!/usr/bin/python

from mparts.analyze import *
import mparts.table as table
import mparts.graph as graph

import sys, os

SCALE = {"MakeKernel" : (("hour", 60*60), ("secs", 1)),
         "Smtpbm" : (("sec", 1), ("microsecs", 1000*1000)),
         "Mkdb" : (("hour", 60*60), ("secs", 1)),
         "Wrmem" : (("hour", 60*60), ("secs", 1)),
         }

def usage():
    print >> sys.stderr, """\
Usage: %s dirs...

Recursively find all benchmark data point directories under the
directories given as arguments and graph those data points.  Separate
benchmark types will be plotted in separate graphs.
""" % sys.argv[0]
    sys.exit(2)

def resultsTable(exps):
    out = []
    haveTimes = False

    for exp in exps:
        best = None
        for rp in filterConfig(exp.config, className = "ResultsProvider"):
            infoTup = (os.path.relpath(exp.path), rp["classNames"][0])
            result = rp["result"]/rp["real"]/rp["cores"]
            resultTup = (rp["cores"], result, rp["units"] + "/sec/core",
                         rp["real"])
            if "time.real" in rp:
                timesTup = (tuple(sum(rp.get("time." + name, 0)
                                     for name in group) / rp["result"]
                                 for group in
                                 [["user", "nice"],
                                  ["sys", "irq", "softirq"],
                                  ["idle", "iowait"]]) +
                            (rp["unit"],))
                haveTimes = True
            else:
                timesTup = ()
                haveTimes = False
            trial = infoTup + resultTup + timesTup
            const = infoTup + (rp["cores"], rp["units"], haveTimes)
            if best != None and best[2] != const:
                raise ValueError(
                    "Trials disagree on constants:\n%r\n versus\n%r" %
                    (best[2], const))
            if best == None or result > best[0]:
                best = (result, trial, const)
        if best == None:
            raise ValueError("No ResultsProviders in %r" % exp)
        out.append(best[1])

    cols = ["path", "className", "cores", "result", "units", "real"]
    if haveTimes:
        cols.extend(["user", "sys", "idle", "timeUnits"])
    desc = table.TableDesc(*cols)
    return table.Table.fromIterable(out, desc)

if len(sys.argv) == 1:
    usage()

graphs = {}
for name, exps in series(*sys.argv[1:]):
    tab = resultsTable(exps)
    fixed = the(tab.project("className", "units"))

    if "user" in tab.desc:
        tunits = the(tab.project("timeUnits")).timeUnits
        rest = (("user/"+tunits, "user"), ("sys/"+tunits, "sys"),
                ("idle/"+tunits, "idle"))
    else:
        rest = ()
    toShow = tab.project("path", "cores", (None, "className"),
                         (fixed.units, "result"), (None, "units"),
                         "real", *rest)
    print toShow.renderText()
    print

    scaleRes, scaleTime = SCALE.get(fixed.className, (("sec", 1), ("secs", 1)))

    g, idx = graphs.get(fixed.className, (None, 0))
    if not g:
        g = graph.Gnuplot()
        g.title = fixed.className
        g.xlabel = "cores"
        g.ylabel = fixed.units.replace("/sec/", "/%s/" % scaleRes[0])
        g.yrange = "[0:*]"
        if "user" in tab.desc:
            # XXX Fudge, have to divide by amount of work.  Perhaps I
            # want to record the absolute result (which will be 1 for
            # the job-oriented benchmarks) and use the measured real
            # time and core count to compute throughput here.  Then
            # use that to compute CPU time per work unit.
            g.y2label = "CPU time (%s/%s)" % (scaleTime[0], tunits)
            g.y2tics = ""
            g.ytics = "nomirror"

    projRes = lambda row: row.result * scaleRes[1]
    g.addData(tab.project("cores", ("result", projRes)),
              with_ = "lines", title = name, linecolor = idx+1)
    if "user" in tab.desc:
        for n, t in [(6, "user"),  # Circle for wx terminal
                     (8, "sys"),   # Triangle
                     (2, "idle")]: # Cross
            projTime = lambda row: getattr(row, t) * scaleTime[1]
            g.addData(tab.project("cores", (t, projTime)), axis = "x1y2",
                      with_ = "linespoints", title = name + " " + t,
                      linecolor = idx+1, pointtype = n)

    graphs[fixed.className] = (g, idx+1)

for g, _ in graphs.itervalues():
    g.plot()
